当执行非常小的数字时，该sqrt并不能给出正确答案， (sqrt 0.000004)的结果应该为0.002

```bash
1 ]=> (sqrt 0.000004)

;Value: .06252124857213626
```

当执行非常大的数字时，该sqrt会进入死循环，在sqrt-iter时，由于数字精度的问题，无法精确计算出good-enough的值，所以死循环了

```bash
1 ]=> (sqrt 9999999999999999999999999999999999999999999999999999999999999999)
^C
Interrupt option (? for help): 
;Quit!
```

题目的提示是比较两次迭代的guess优化的比例，若优化比例很小，则停止迭代。

也就是将加减法变为乘除法，我的做法是比较guess和x的比例，如无限接近1则停止迭代，good-enough 代码如下

```lisp
(define (good-enough guess x)
  (< (abs (- 1 (/ (square guess) x))) 0.0001))
```

优化后，对于很小和很大的数计算结果如下

```bash
1 ]=> (sqrt 0.000004)

;Value: 2.0000003065983023e-3

1 ]=> (sqrt 9999999999999999999999999999999999999999999999999999999999999999)

;Value: 1.0000046085713034e32
```

